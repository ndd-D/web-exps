要在Spring Boot项目中使用事务操作，需要进行以下准备工作：

## 1. 添加事务依赖

在Spring Boot中，如果你已经使用了`spring-boot-starter-data-jpa`或`spring-boot-starter-jdbc`，事务支持已经自动包含。如果没有，可以添加：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>

<!-- 或者只使用JDBC事务 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```


## 2. 启用事务管理

在Spring Boot中，默认已经启用了事务管理。但也可以显式地在配置类或启动类上添加注解：

```java
@SpringBootApplication
@EnableTransactionManagement  // 显式启用事务管理（通常不需要）
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```


## 3. 配置数据源和事务管理器

### 数据源配置（application.yml）：
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/your_database
    username: your_username
    password: your_password
    driver-class-name: com.mysql.cj.jdbc.Driver
```


### 自定义事务管理器（可选）：
```java
@Configuration
public class TransactionConfig {
    
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```


## 4. 使用@Transactional注解

### 在Service层使用事务：
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private AccountRepository accountRepository;
    
    @Transactional
    public void transferMoney(Long fromUserId, Long toUserId, BigDecimal amount) {
        // 扣除转出方金额
        Account fromAccount = accountRepository.findByUserId(fromUserId);
        fromAccount.setBalance(fromAccount.getBalance().subtract(amount));
        accountRepository.save(fromAccount);
        
        // 增加转入方金额
        Account toAccount = accountRepository.findByUserId(toUserId);
        toAccount.setBalance(toAccount.getBalance().add(amount));
        accountRepository.save(toAccount);
        
        // 记录转账日志
        TransferLog log = new TransferLog(fromUserId, toUserId, amount);
        transferLogRepository.save(log);
    }
    
    // 指定特定的事务管理器
    @Transactional(transactionManager = "transactionManager")
    public void createUser(User user) {
        userRepository.save(user);
    }
    
    // 只读事务
    @Transactional(readOnly = true)
    public List<User> getAllUsers() {
        return userRepository.findAll();
    }
}
```


## 5. 事务传播行为配置

### 常用的事务传播行为：
```java
@Service
public class BusinessService {
    
    @Autowired
    private UserService userService;
    
    // REQUIRED：默认行为，如果当前存在事务则加入，否则创建新事务
    @Transactional(propagation = Propagation.REQUIRED)
    public void method1() {
        // 业务逻辑
    }
    
    // REQUIRES_NEW：总是创建新事务
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void method2() {
        // 业务逻辑
    }
    
    // SUPPORTS：支持当前事务，如果没有则以非事务方式执行
    @Transactional(propagation = Propagation.SUPPORTS)
    public void method3() {
        // 业务逻辑
    }
    
    // MANDATORY：支持当前事务，如果没有则抛出异常
    @Transactional(propagation = Propagation.MANDATORY)
    public void method4() {
        // 业务逻辑
    }
}
```


## 6. 事务隔离级别配置

```java
@Service
public class TransactionService {
    
    // 默认隔离级别
    @Transactional
    public void defaultIsolation() {
        // 使用数据库默认隔离级别
    }
    
    // 读已提交
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void readCommitted() {
        // 业务逻辑
    }
    
    // 读未提交
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public void readUncommitted() {
        // 业务逻辑
    }
    
    // 可重复读
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void repeatableRead() {
        // 业务逻辑
    }
    
    // 串行化
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void serializable() {
        // 业务逻辑
    }
}
```


## 7. 异常回滚配置

```java
@Service
public class ExceptionHandlingService {
    
    // 默认情况下，RuntimeException和Error会触发回滚
    @Transactional
    public void defaultRollback() {
        // 抛出RuntimeException会自动回滚
        throw new RuntimeException("出错回滚");
    }
    
    // 指定检查异常也触发回滚
    @Transactional(rollbackFor = Exception.class)
    public void rollbackForCheckedException() throws Exception {
        // 抛出检查异常也会回滚
        throw new Exception("检查异常也会回滚");
    }
    
    // 指定某些异常不触发回滚
    @Transactional(noRollbackFor = IllegalArgumentException.class)
    public void noRollbackForSpecificException() {
        // 抛出IllegalArgumentException不会回滚
        throw new IllegalArgumentException("不会触发回滚");
    }
}
```


## 8. 事务超时设置

```java
@Service
public class TimeoutService {
    
    // 设置事务超时时间（秒）
    @Transactional(timeout = 30)
    public void longRunningOperation() {
        // 长时间运行的操作
    }
}
```

## 9. 编程式事务管理

如果需要更细粒度的事务控制，可以使用编程式事务：

```java
@Service
public class ProgrammaticTransactionService {
    
    @Autowired
    private PlatformTransactionManager transactionManager;
    
    public void performOperation() {
        TransactionDefinition def = new DefaultTransactionDefinition();
        TransactionStatus status = transactionManager.getTransaction(def);
        
        try {
            // 执行业务逻辑
            // ...
            
            transactionManager.commit(status);
        } catch (Exception ex) {
            transactionManager.rollback(status);
            throw ex;
        }
    }
}
```


## 10. 测试事务配置

### 在测试中使用事务：
```java
@SpringBootTest
@Transactional
@Rollback
class TransactionalServiceTest {
    
    @Autowired
    private UserService userService;
    
    @Test
    void testTransferMoney() {
        // 测试代码
        // 测试完成后事务会自动回滚
    }
}
```


完成以上配置后，就可以在项目中使用Spring的事务管理功能了。通过`@Transactional`注解可以轻松实现声明式事务管理，保证数据的一致性和完整性。