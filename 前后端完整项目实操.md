## 前后端完整项目实操

### 后端

1. 创建`springboot`项目，勾选需要添加的依赖

2. 连接数据库，配置yml

   ```yaml
   spring:
     datasource:
       url: jdbc:mysql://localhost:3306/test
       driver-class-name: com.mysql.cj.jdbc.Driver
       username: root
       password: 12345
   ```

3. 开启驼峰命名

   ```yaml
   mybatis-plus:
     configuration:
       map-underscore-to-camel-case: true

   logging:
     level:
       com.ndd.test: DEBUG
   ```

   ​

4. 分别创建`controller` `service` `mapper` `entity\pojo` `config` `utils`等软件包

   | 包名        | 注解            | 继承/接口                                                    |
   | ----------- | --------------- | ------------------------------------------------------------ |
   | controller  | @RestController | 类                                                           |
   | service     |                 | 接口继承IService<entity>                                     |
   | impl        | @Service        | 类继承ServiceImpl<mapper,entity>接口service                  |
   | mapper      | @Mapper         | 接口继承BaseMapper<entity>                                   |
   | entity/pojo | @Data           | 类，要和数据库保持一致，在数据库列名与entity里定义的不一样时需要加注解说明，插入时间和更新时间的管理也可以加`@TableField`注解。至于要不要@All和@No，看后续用不用得到 |
   | config      | @Configuration  |                                                              |
   | utils       | @Component      |                                                              |

   3. Result类必须写注解@Data，否则api测试会报错

   4. Swagger直接引入依赖，即可使用@Operation

      ```xml
      <dependency>
                  <groupId>org.springdoc</groupId>
                  <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
                  <version>2.1.0</version>
      </dependency>
      ```

      访问 http://localhost:8080/swagger-ui/index.html 可进行测试

   5. 写controller类，注解主要有`@RequestBody` `RequestParam` `PathVariable`，body用来接收`json`格式；param接收独立传过来的变量；path接收{}里的内容。

   6. 3.5.3版本的直接就能进行单元测试，如果有不行的记得检查spring boot版本，还有其他的，如果不能用，可能就是版本问题。

### 前端

1. 创建，在当前页面的`cmd`上输入以下命令——`npm init vue@latest`，勾选router

2. 创建`pages/currentPage.vue`随便写几句，在router里配置页面

   ```js
   import { createRouter, createWebHistory } from 'vue-router'

   const router = createRouter({
     history: createWebHistory(import.meta.env.BASE_URL),
     routes: [
         {
           path: '/',
           name: 'users',
           component: () => import('@/pages/users.vue'),
         },
     ],
   })

   export default router

   ```

3. 在`App.vue`配置路由

   ```vue
   <script setup></script>

   <template>
     <div>
       <router-view></router-view>
     </div>
   </template>

   <style scoped></style>
   ```

4. 配置`axios`用于网络请求——`npm install axios`

5. 连接后端要配置代理`vite.config.js`

   ```js
   import { fileURLToPath, URL } from 'node:url'
   import { defineConfig } from 'vite'
   import vue from '@vitejs/plugin-vue'
   import vueDevTools from 'vite-plugin-vue-devtools'

   // https://vite.dev/config/
   export default defineConfig({
     plugins: [
       vue(),
       vueDevTools(),
     ],
     resolve: {
       alias: {
         '@': fileURLToPath(new URL('./src', import.meta.url))
       },
     },
     // 添加代理配置（Vite方式）
     server: {
       proxy: {
         '/api': {
           target: 'http://127.0.0.1:8080',
           changeOrigin: true,
           rewrite: (path) => path.replace(/^\/api/, '')
         }
       }
     }
   })
   ```

6. 创建`utils/request.js`，配置`axios`拦截器和基础路径

   ```js
   import axios from 'axios'
   const request = axios.create({
       baseURL: '/api' // 以 /api 为基础路径，配合代理转发
   })
   export default request
   ```

7. 创建`api/entity.js`，封装网络请求的接口，在页面随便写几句，看前端F1网络是否报错，报错就在后端安个跨域

   ```js
   import request from '../utils/request'
   export const getList = () => request.get('/users/list')
   export const addEntity = (data) => request.post('/entities', data)
   export const updateEntity = (id, data) => request.put(`/entities/${id}`, data)
   export const deleteEntity = (id) => request.delete(`/entities/${id}`)
   ```

8. 开始写pages页面，在写`axios`时，记得检查`await request.get('/users/list') `括号里的和后端的是否一致，必须一致！在赋值时，用ref空数组接收。一般查询都在onMounted挂载，即页面到位它就到位。

   ```js
   <script setup>
   import {getUserList} from "@/api/entity.js";
   import {onMounted, ref} from "vue";

   const userList=ref([])

   onMounted(async() =>{
     const res=await getUserList()
     userList.value=res.data.data
     console.log("fuck:",userList.value)
   })
   </script>
   ```

   也可以用函数接收：

   ```js
   <script setup>
   import {getUserList} from "@/api/entity.js";
   import {onMounted, ref} from "vue";

   const userList=ref([])

   const fetchUserList=async () => {
     const res=await getUserList()
     userList.value=res.data.data
   }

   onMounted(() =>{
     fetchUserList()
   })
   </script>
   ```

   9. 前后端接口`api.js`和`controller`的请求，要完全对应

   ```js
   @PathVariable String id, // 接收路径参数id   
       ('/users${id}')
   @RequestParam String keyword, // 接收查询参数keyword
       ('/users',{params:{keyword}})
   @RequestBody YourDataClass data // 接收请求体参数（JSON格式）
   	('/users',data)
   ```

   ​10. `api`的函数与页面处理的函数不能重名